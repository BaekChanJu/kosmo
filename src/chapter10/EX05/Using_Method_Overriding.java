package chapter10.EX05;

//<메소드오버로딩>
//메소드 오버로딩 :
//	-동일한 메소드 이름에 대해서 시그니처가 다를 경우, 다른 메소드로 식별해 인식한다
	// - 시그니처 : 1.매소드의 입력매개변수의 갯수로 구별, 입력매개변수의 타입으로 구별
				//메소드 이름은 동일해도 매개변수의 갯수가 다르거나 서로 타입이 다르면 다른메소드다 라고 식별
		//생성자나 메소드에서 이용된다 메소드이름은 동일 하지만 시그니처가 달라서 다른걸로 인식하는

//하지만 중요! 리턴 타입은 시그니처에 포함되지 않음 void , int 같은




//<메소드오버라이딩>
//메소드 오버라이딩 : 상속관계일때 만 사용가능 (상속이 아니면 오버라이딩이 불가)
//	-부모의 메소드를 자식클래스에서 새롭게 정의해서 사용하는 것 
		//즉 부모꺼를 가져와서 새롭게 나만의 것을 창조해서 정의하는것이다

//	-자식클 에서 부모클 의 메소드를 오버라이딩 하기위한 조건은?
//	1) 리턴타입이 같아야한다 (Void면 void , int 면 int)
//	2) 메소드이름이 같아야한다
//	3) 시그니처가 같아야한다(메소드 입력매개변수 갯수, 매개변수의 타입)
//	4) 접근제어자는 부모클래스의 접근제어자와 같거나 더 넓은 타입이여야 한다
		//접근제어자: public protected default 이런거

// @o 하고 컨트롤 스페이스 해주면 @Override생성됨 : 오버라이드어노테이션 이라부르고 @<어노테이션
	//자식클래스에서 메소드 오버라이딩할때 오류를 방지하기 위해 사용한다
//정확히 오버라이딩 할수있도록 선언해주면 잘못된 부분들을 빨간 밑줄 쳐주는 역활

//오버라이딩하면 자식이 부모의 메소드를 덮어쓰는것이다 부모의메소드가 삭제되는 것은 아니다


class Mom{
	void print() { //오버라이딩하려면 <리턴타입,메소드이름,시그니처 다 같아야함>
		System.out.println("Mom 클래스 출력");
	}
	
}

class Son extends Mom{
	
	@Override //오류 방지설정
	void print() { // 메소드오버라이딩 당했음 : 리턴 메소드명 시그니처 지금Mom이랑 다같음
		//부모의 기능은 쓰지않고 자식의 메소드로 부모를 덮어써 버리는거임 이게 오버라이딩임
		//실제로 부모 메소드는 삭제는 아니고 자식이 그위를 덮어쓴거라 생각하면된다
		
		//객체는 Son으로 만들고 타입을 Mom으로 할시 이럴경우 오버라이딩이 되서 출력하게된다
		//일반적으로 동일하게 설정하면 그 내용이 출력되고
		System.out.println("Son 클래스 출력");
	}
}










public class Using_Method_Overriding {

	public static void main(String[] args) {
		//1.Mom객체생성을 Mom타입으로 지정해서
		Mom aa1 = new Mom(); 
		aa1.print(); //Mom 클래스 출력
		
		//2.Son 객체를 Son 타입으로
		Son bb1 = new Son();
		bb1.print(); //Son 클래스 출력
		
		//3.Son 객체를 Mom 타입으로 지정해서출력 <여기가 오버라이딩이 되는것임>
		Mom aa2 = new Son();
		aa2.print(); //Mom타입으로 지정을했으니 Mom의 내용이 나와야하는데
		//오버라이딩이 되어서 Son의 내용이나온다 / Son 클래스 출력

	}

}
